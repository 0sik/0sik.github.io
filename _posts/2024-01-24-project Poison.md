---
layout: single
title: "독초 판별 서비스(POISON)"
toc: true
toc_sticky: true
toc_label: "목차"
categories: project
toc_icon: "bars"
tags: [project]
---
📘 독초 판별 서비스(POISON)

지금까지 여러가지 프로젝트를 하면서 정말 많이 배웠다고 생각하는데, 막상 기술들을 물어보거나 기술들을 왜 썼는지
물어보면 말을 잘 못할때가 있다. 면접준비을 보면서 느꼈고, 이 기회에 지금까지 한 프로젝트를 정리하면서
다시 공부하는 시간을 가져야 겠다고 생각했다. 중점으로 볼것은 그 기술을 왜 선택하게 되었는지, 그 기술을 선택함으로
얻는 이점이나 효과에 대해 정리해볼 예정이다. 내가 처음 한 프로젝트 독초 판별 서비스(POISON)에 대해 정리해보겠다.

# 서비스 내용
이미지를 업로드 하면 AI가 식물중 가장 비슷한 식물을 판별한 후 사용자에게 알려주는 서비스
또한 학습된 식물들의 리스트 및 식물 정보를 볼 수 있는 페이지(도감리스트 전체를 로딩하는것이 아닌 무한스크롤을 통해 필요한 만큼의 데이터 로딩)
도감에 등록된 식물을 검색할 수 있고, 판별 결과로 많이 조회된 순으로 랭킹을 보여주는 기능도 추가
총 3가지의 중요한 기능이 있다.
기능들을 설명하기 보단 이 기술을 왜 썼는지 이유를 정리해보자.

# 백엔드 서버가 두개
우리는 백엔드 서버를 두개를 두었다.
Django는 데이터베이스와 프런트엔드 간의 통신을 관리하는 메인 백엔드 서버와 AI결과보고 및 AI모델이 있는 Flask서버 두개가 있다.
ORM(Object-Relational Mapping),많은 내장 기능을 제공표준 웹 애플리케이션의 신속한 개발에 적합하고 프런트 엔드와 데이터베이스 간의 일반적인 데이터 흐름을 처리하는 데 매우 적합하기때문에 메인 백엔드 서버는 Django로 두었고, Flask의 단순성과 가벼운 특성으로 인해 집중적인 마이크로서비스를 구축하는 데 이상적이어서 AI서버로는 Flask서버로 두었다.

이렇게 백엔드 서버를 두개를 만든 이유가 무었일까?

## 백엔드 서버를 두개를 둔 이유
1. 관심사 전문화 및 분리
AI서버와 프론트엔드 간의 통신을 관리하는 메인서버 두개를 분리하여 각각 서버의 관심사를 분리할수있다.

2. 확장성

메인 백엔드 서버(Django)를 AI 서버(Flask)에서 분리하면 특정 리소스 요구 사항에 따라 이러한 구성 요소를 독립적으로 확장할 수 있다. 예를 들어 AI 관련 작업이 리소스 집약적인 경우 기본 백엔드 서버에 영향을 주지 않고 Flask 서버에 추가 리소스(예: 컴퓨팅 성능, 메모리, 스토리지)를 할당할 수 있다.

3. 기술 스택 유연성

애플리케이션의 구성 요소마다 기술 스택 요구 사항이 다를 수 있다. Django와 Flask를 사용하면 종속성과 라이브러리를 유연하게 선택할 수 있다. 이러한 분리를 통해 각 백엔드 서버에 가장 적합한 기술 스택을 선택하여 각 구성 요소의 개발 및 성능을 최적화할 수 있다.

4. 모듈화 및 유지 관리성

백엔드를 두 개의 서버로 나누면 모듈화가 촉진된다. AI 관련 기능에 대한 변경이나 업데이트를 Flask 서버로 격리하여 기본 백엔드 서버에 영향을 미칠 위험을 줄일 수 있다. 이러한 분리로 인해 유지 관리성이 향상되고 시스템의 다양한 부분을 더 쉽게 이해하고 관리할 수 있다.

# S3사용 이유
데이터베이스에 사진을 담기 위해 무엇을 쓸지 고민하다 쓴것은 S3이다. 데이터베이스에 사진 그 자체가 들어가게 되면 용량이 너무 커버리게 된다.
이때 S3를 사용하여 이미지의 url을 s3 bucket에 저장하여 데이터베이스에는 사진이 아닌 url을 저장하였다.

# 검색엔진을 사용한 이유
우리가 꽃을 검색할때 "진달래"를 치고싶은데 100이면 100번을 "진달래"로 치는것이 아니고 "진달레", "진덜래" 이런식으로 오타가 생기기 마련이다. 이런 사용자 경험을 개선시키고자 MongoDB Atlas Search를 사용하여 꽃 이름 유사어 검색 및 다중검색이 가능하도록 검색엔진을 구현하였다.

# 비동기 처리
이 프로젝트에서는 사용자가 사진을 올리면 그 사진이 독초인지 아닌지 판별하는 기능에 비동기 처리 방식을 썼다.
예를 들어서 여러 개의 수신 HTTP 요청을 동시에 처리해야 하는 웹 서버가 있다. 비동기식 처리가 없으면 서버는 한 번에 하나의 요청을 처리할 수 있으므로 응답 시간이 느려지고 병목 현상이 발생할 수 있다.
비동기식 처리를 통해 서버는 요청을 동시에 처리하여 전반적인 성능을 향상시킬 수 있다. 이 프로젝트를 예를 들어, 들어오는 각 사진을 서버에 처리 요청을 트리거한다. 비동기식 처리를 통해 서버는 여러 요청을 동시에 처리할 수 있으므로 한 사용자로 인해 다른 사용자의 메시지 처리가 지연되지 않게 설계한것이다.

비동기 처리를 통해 서버는 리소스를 효율적으로 활용할 수 있다. 예를 들어 하나의 메시지 요청에 시간이 걸리는 데이터베이스 쿼리 또는 외부 API 호출이 포함된 경우 서버는 대기 기간 동안 다른 요청 처리로 전환하여 리소스가 유휴 상태가 되지 않도록 할 수 있다.




- **비동기 처리**를 위해 Celery를 사용, Celery저장값을 저장시켜주는 Redis 사용, 메시지브로커로 RabbitMq 사용
- **Polling 방식**을 활용해 Celery가 요청처리중에도 다른 요청들을 받을 수 있게 구현