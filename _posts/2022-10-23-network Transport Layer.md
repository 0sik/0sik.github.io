---
layout: single
title: "Transport Layer"
toc: true
toc_sticky: true
toc_label: "목차"
categories: network
toc_icon: "bars"
tags: [network]
---

📘컴퓨터 네트워크

# Transport service
- 다른 호스트에서 실행되는 애플리케이션 프로세스 간에 논리적인 통신을 제공
-트랜스포트 프로토콜은 종단시스템에서 실행
  - 송신측 : 애플리케이션 메시지는 세그먼트로 분할되어 네트워크 계층에 전달
    - 세그먼트 헤더 값 결정
    - 세그먼트 생성
    - 생성된 세그먼트를 ip계층에 전달
  - 수신측 : 세그먼트를 메시지로 재결합하고 애플리케이션 계층에 전달
    - ip계층에서 세그먼트 수신
    - 헤더 값 점검
    - 응용계층에 전달할 메시지 추출
    - 소켓 경유하여 응용 계층으로 메시지 역다중화 전송
- 인터넷 응용 프로그램에서 선택 가능한 2가지 트랜스포트 프로토콜 : TCP,UDP

# 다중화
- 송신측 다중화 : 응용 계층의 다수 소켓으로부터 데이터를 받아 추후 역다중화에 대비하여 트랜스포트 헤더 추가

# 역다중화
- 수신측 역다중화 : 네트워크 계층에서 헤더 정보기반으로 수신된 세그먼트를 적합한 소켓으로 전달
- 호스트는 ip데이터그램 수신
  - 각 데이터그램에는 송신지 ip주소와 목적지 ip주소 포함
  - 각 데이터그램은 한개의 트랜스포트 계층 세그먼트 포함시켜 전송
  - 각 세그먼트는 송신지와 목적지 포트번호 포함
- 호스트는 수신한 세그먼트에 포함된 ip주소와 포트번호 이용하여 적절한 소켓으로 전달

# UDP
- 비연결형 트랜스포트 프로 토콜
- UDP 송수신자 간 핸드쉐이킹 없음
- 각 UDP세그먼트는 독립적으로 처리
- RTT지연을 유발하는 연결 설정 불필요 
- 송수신자간에 연결 상태 관리 불필요
- 작은 헤더 크기
- 혼잡 제어 없음

## UDP 송신자 동작 절차
- 응용 계층의 메시지 전달받음
- UDP세그먼트 헤더 값 결정
- UDP 세그먼트 생성
- 생성된 세그먼트를 ip계층으로 전달

## UDP수신자 동작 절차
- ip계층에서 세그먼트 수신
- UDP 헤더 값 중 체크섬 값 점검
- 응용 계층의 메시지 추출
- 소켓 경유하여 응용 계층으로 메시지 역 다중화

## 체크섬 
- 수신된 세그먼트에 포함되어 전송 중 에러 탐지 용도
- 두개의 16비트 정수 더하고 sum의 보수 checksum 궇기

# 신뢰기반 통신 관련 용어
- ARQ 방식 : 재전송을 기반으로 링크의 신뢰성을 확보하는 기법
  - 수신자가 송신자에 재전송을 요구
    - 수신 패킷에 포함된 오류 검출 정보로부터 에러 포함 여부 점검하고,해당 패킷의 재전송 요청
    - 정상 수신 패킷에 대한 정상 확인(ACK)과 비정상 수신 패킷에 대한 부정 확인(NAK) 사용
    - 송신자는 타이머에 대기 시간 설정 후 패킷 송신하고 설정 시간 내 회신 없을 경우 재전송
  - 오류 정정 체계가 아닌 오류 검출 만으로도 통신 회선의 신뢰성 확보 가능
  - 기능 : 오류 검출, 송신자에 의한 수신자의 수신 여부 확인

1. 정지 대기 방식
- 송신자가 수신자에 한개의 패킷을 전송하고 대기 상태에서 긍정 확인 응답을수신하면,후속 패킷을 전송
2. GoBackn ARQ방식
- 송신자가 수신자에 한번에 여러개의 패킷을 보낸 후 하나의 최종 긍정확인 응답을 수신하면 다음순서의 여러 패킷을 순차전송
3. Selective Repeat ARQ
- 송신자가 수신자에 한번에 여러개의 패킷을 보낸후 수신자로부터 NAK를 수신하면, NAK에서 지정한 패킷 또는 지정한 이후 패킷을 순차 재전송

# rdt
- 단반향 데이터 전송만 고려
- 송신자와 수신자 간 동작 정의에 유한 상태 머신(FSM)사용

## rdt1.0
- 송신자와 수신자 간에 분리된 FSM
  - 송신자는 하위 채널에 데이터 전송
  - 수신자는 하위 채널로부터 데이터 수신

## rdt2.0
- 하위 채널에서 비트 오류 발생 가능 (체크섬 이용하여 비트 오류 검출)
- 손신자는 NAK수신되면 패킷 재전송 
- stop and wait(전송 후 대기)
> 오류
> ACK/NAK 자체의 비트 전송 오류가 발생할 경우 :
> 이 경우 송신자는 수신자의 상황을 알 수 없음
> 단순하게 재전송할수도없음:중복패킷발생
> 
> 중복 패킷 처리 : 
> 송신자는 NAK패킷 수신하면 현재 패킷을 재전송
> 송신자는 각 패킷에 순서 번호 추가 --> rdt2.1
> 수신자는 중복 패킷 버림
>
>  여기서 NAK만 없고 ACK에 번호가 있는것이 --> rdt2.2

# rdt 3.0
- 하위 채널은 데이터 똔느 ACK를 상실할 수 있음
- 송신자는 수신자의 ACK가 회신되기까지 합리적인 시간 동안 대기

# GO-BACK-N 
- 송신자 : ACK 수신되지 않은 패킷 포함해서 "윈도우" 크기 N까지 누적 전송
- 수신자 : 현재까지 정상 수신된 패킷들에 대한 오름차순의 순서번호로 ACK송신
  - 오름차순으로 가장 높은 순서 패킷에 대한 ACK 재전송(묶음으로 전송)
- 묶음으로 전송하면 낭비니까 선택적 반복사용
# 선택적 반복 : 수신자는 정상 수신된 패킷에 대한 개별 확인 응답
- 송신자는 ACK 응답을 받지 못한 패킷만을 재전송
  - 선택적 반복의 한계(윈도우 크기가 클 경우) : 수신자가 프레임이 중복인지 새로운 데이터인지 파악하기 힘들어 확보된 공간에 저장해버림
    - 윈도우 크기 <= 송신번호 공간크기/2

# TCP
- 1대1 : 송신자오 수신자 각각 한개
- 신뢰 기반, 순서 기반 연속 스트림
- 누적 ACK
> 순서 번호 
> - 송신자의 송신 세그먼트에서 전송되는 데이터의 시작 순서 번호
> ACK 번호
> - 수신자로부터 송신자가 직전에 정상 수신한 세그먼트의 데이터의 마지막 번호 다음 번호

> 순서번호 42 ack 79 ->
> <- 순서번호 79 ack 43
> 순서번호 43 ack 80->

- TCP 타임아웃 값은 어떻게 설정하는가
  - RTT보다 커야하지만 RTT는 고정 아닌 가변
  - 너무 짧다면 : 잦은 타임아웃과 불필요한 재전송
  - 너무 길다면 : 세그먼트 손실 대응 지연

# TCP ACK 생성 권고
1. 기다리는 순서번호를 가진 순서에 맞는 세그먼트의 도착 기다리는 순서번호까지의 모든 데이터는 이미 수신
- 지연된 ACK. 다음 세그먼트가 도착할때까지 최대 500ms를 기다림 만약에 그때까지 다음 세그먼트가 도착하지 않으면 ACK를 보냄
2. 기다리는 순서번호를 가진 순서에 맞는 세그먼트가 도착 ACK전송을 기다리는 또 다른 세그먼트가 존재
- 즉시 두개의 순서에 맞는 세그먼트에 대해서 하나의 누적된 ACK를 보냄
3. 기다리는 것보다 높은 순서번호를 가진 순서가 틀린 세그먼트가 도착하여 간격이 발견됨(중간에 한 세그먼트가 안옴)
- 기다리는 바이트 순서번호를 포함한 중복 확인 응답을 보냄
4. 수신된 데이터가 간격을 부분적 또는 모두 채우는 경우
- 수신된 세그먼트가 가장 낮은 순서번호를 가진간격을 채우는 경우 , 즉시 ACK를 보냄

# 흐름제어(flow control)
- TCP 연결의 수신자는 수신 버퍼를 가지고 있음
- 흐름제어 : 송신자는 데이터를 너무 많이, 너무 빨리 보내서 수신자의 버퍼를 넘치게 하지 않음
  - 수신자가 송신자의 전송을 제어하여 , 수신자 수신 버퍼의 여유 공간 이상으로 과도하거나 빠르게 데이터를 전송하지 못하도록 제어하는것
- 속도 일치 서비스 : 보내는 속도를 애플리케이션이 읽는 속도와 같게 해줌
- 애플리케이션 프로세스가 버퍼로부터 데이터를 읽는 것이 많이 느릴 수 있음
- 수신자가 세그먼트에 RcvWindow 의 값을 포함하는 방법으로 사용 가능한 버퍼 공간을 알려줌
- 송신자가 확인 응답 되지 않은 데이트의 크기를 RcvWindow로 제한

# TCP 연결 , 연결 종료
- 연결관리 : 핸드 쉐이킹을 통해 연결 관리 (2,3way handshake가있다)
- 3방향 handshake
  - 1. 클아이언트가 TCPSYN세그먼트를 서버로 보냄(최초의 순서번호 선택, 데이터 없음)
  - 2. 서버가 SYN을 받고 SYNACK세그먼트로 응답(서버가 버퍼를 할당, 서버의 최초 순서번호를 선택)
  - 3. 클라이언트가 SYNACK를 받아 ACK세그먼트로 응답
- 연결 종료 : 클라이언트와 서버는 필요시 주도적으로 연결을 종료
  - Fin 비트 = 1로하여 상대방으로 TCP세그먼트 전송

# 혼잡제어의 원칙
- 네트워크가 처리하지 못 할 수준으로 여러 발신지에서 많은 데이터를 빠르게 전송하는것
- 현상 : 패킷지연(라우터버퍼에서 큐잉) 패킷 손실(라우터에서 버퍼 오버 플로우)

- 퍀킷은 라우터의 버퍼가 가득차면 손실되거나 버려질 수 있음 - 재전송 필요함
- 하지만 송신자는 타임아웃에 의해 이미 잘 전될된 패킷을 재 전송할 수도 있음